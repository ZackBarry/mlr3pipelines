% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Graph.R
\docType{data}
\name{Graph}
\alias{Graph}
\title{Graph}
\format{\link{R6Class} Graph}
\usage{
Graph
}
\description{
A \code{Graph} is a representation of a machine learning pipeline graph. It is made up of a list of
PipeOps, and a \code{\link{data.table}} of edges. It can be trained and used for prediction.
}
\section{Public Members / Active Bindings}{

\itemize{
\item \code{pipeops}      :: named \code{list} of \code{\link{PipeOp}} \cr
Contains all \code{PipeOp}s in the Graph, named by the \code{PipeOp}'s \code{$id}.
\item \code{edges}        :: \code{\link{data.table}}  with \code{character} columns \code{src_id}, \code{src_channel}, \code{dst_id}, \code{dst_channel} \cr
Table of connections between the \code{PipeOp}s. A \code{data.table}. \code{src_id} and \code{dst_id} are \code{$id}s of \code{PipeOp}s that must be present in
the \code{$pipeops} list. \code{src_channel} and \code{dst_channel} must respectively be \code{$output} and \code{$input} channel names of the
respective \code{PipeOp}s.
\item \code{is_trained}   :: \code{logical(1)} \cr
Is the \code{Graph}, i.e. are all of its \code{PipeOp}s, trained, and can the \code{Graph} be used for prediction?
\item \code{lhs}          ::  \code{character(n)} \cr
Ids of the 'left-hand-side' nodes that have some unconnected input channels and therefore act as \code{Graph} input layer.
\item \code{rhs}          :: \code{character(n)} \cr
Ids of the 'right-hand-side' nodes that have some unconnected output channels and therefore act as \code{Graph} output layer.
\item \code{input}        :: \code{\link{data.table}} with \code{character} columns \code{name}, \code{train}, \code{predict}, \code{op.id}, \code{channel.name} \cr
Input channels of the \code{Graph}. For each channel lists the name, input type during training, input type during prediction,
\code{PipeOp} \code{$id} of the \code{PipeOp} the channel pertains to, and channel name as the \code{PipeOp} knows it.
\item \code{output}        :: \code{\link{data.table}} with \code{character} columns \code{name}, \code{train}, \code{predict}, \code{op.id}, \code{channel.name} \cr
Output channels of the \code{Graph}. For each channel lists the name, output type during training, output type during prediction,
\code{PipeOp} \code{$id} of the \code{PipeOp} the channel pertains to, and channel name as the \code{PipeOp} knows it.
\item \code{packages}     :: \code{character} \cr
Set of all required packages for the various methods in the \code{Graph}, a set union of all required packages of all contained
\code{\link{PipeOp}} objects.
\item \code{model}        :: named \code{list} \cr
Get / Set the \code{$state} of each of the members of \code{PipeOp}.
\item \code{param_set}    :: \code{\link{ParamSet}} \cr
Parameters and parameter constraints. Parameter values are in \code{$param_set$values}. These are the union of \code{$param_set}s
of all \code{PipeOp}s in the \code{Graph}. Parameter names
as seen by the \code{Graph} have the naming scheme \code{<PipeOp$id>.<PipeOp original parameter name>}.
Changing \code{$param_set$values} also propagates the changes directly to the contained
\code{PipeOp}s and is an alternative to changing a \code{PipeOp}s \code{$param_set$values} directly.
\item \code{hash}         :: \code{character(1)} \cr
Stores a checksum calculated on the \code{Graph} configuration, which includes all \code{PipeOp} hashes
(and therefore their \code{$param_set$values}) and a hash of \code{$edges}.
\item \code{keep_results} :: \code{logical(1)} \cr
Whether to store intermediate results in the \code{PipeOp}'s \code{$.result} slot, mostly for debugging purposes. Default \code{FALSE}.
}
}

\section{Methods}{

\itemize{
\item \code{Graph$new()} \cr
() -> \code{self} \cr
Constructs an empty Graph.
\item \code{ids(sorted = FALSE)} \cr
(\code{logical(1)}) -> \code{character} \cr
Get IDs of all PipeOps. This is in order that PipeOps were added if
\code{sorted} is \code{FALSE}, and topologically sorted if \code{sorted} is \code{TRUE}.
\item \code{add_pipeop(op)} \cr
(\code{\link{PipeOp}} | \code{character(1)}) -> \code{self} \cr
Mutates \code{Graph} by adding a \code{PipeOp} to the \code{Graph}. This does not add any edges, so the new \code{PipeOp}
will not be connected within the \code{Graph} at first.
\item \code{add_edge(src_id, dst_id, src_channel = NULL, dst_channel = NULL)} \cr
(\code{character(1)}, \code{character(1)},
\code{character(1)} | \code{numeric(1)} | \code{NULL},
\code{character(1)} | \code{numeric(1)} | \code{NULL}) -> \code{self} \cr
Add an edge from \code{PipeOp} \code{src_id}, and its channel \code{src_channel}
(identified by its name or number as listed in the \code{PipeOp}'s \code{$output}), to \code{PipeOp} \code{dst_id}'s
channel \code{dst_channel} (identified by its name or number as listed in the \code{PipeOp}'s \code{$input}).
If source or destination \code{PipeOp} have only one input / output channel and \code{src_channel} / \code{dst_channel}
are therefore unambiguous, they can be omitted (i.e. left as \code{NULL}).
\item \code{plot(html)} \cr
(\code{logical(1)}) -> \code{NULL} \cr
Plot the graph, using either the \code{\link[igraph:igraph-package]{igraph}} package (for \code{html = FALSE}) or
the \code{visNetwork} package for \code{html = TRUE} producing a htmlWidget. Defaults to \code{FALSE}.
\item \code{print()} \cr
() -> \code{NULL} \cr
Print a representation of the graph on the console. Output is a table with one row for each contained \code{PipeOp} and
columns \code{ID} (\code{$id} of \code{PipeOp}) and \code{State} (short representation of \code{$state} of \code{PipeOp}).
\item \code{set_names(old, new)} \cr
(\code{character}, \code{character}) -> \code{self} \cr
Rename PipeOps: Change ID of each PipeOp as identified by \code{old} to the corresponding item in \code{new}. This should be used
instead of changing a \code{PipeOp}'s \code{$id} value directly!
\item \code{train(input, single_input = TRUE)} \cr
(\code{any}, \code{logical(1)}) -> \code{list} of \code{any} \cr
Train \code{Graph} by calling all the \code{PipeOp}'s \code{$train} methods. Return a named \code{list} of outputs for each unconnected
\code{PipeOp} out-channel, named according to the \code{Graph}'s \code{$output} \code{name} column. During training, the \code{$state}
member of the \code{PipeOp}s will be set and the \code{$is_trained} slot of the \code{Graph} (and each individual \code{PipeOp}) will
consequently be set to \code{TRUE}.\cr
If \code{single_input} is \code{TRUE}, the \code{input} value will be sent to each unconnected \code{PipeOp}'s input channel
(as listed in the \code{Graph}'s \code{$input}). Typically, \code{input} should be a \code{\link{Task}}. If \code{single_input} is \code{FALSE}, then
\code{input} should be a \code{list} with the same length as the \code{Graph}'s \code{$input} table has rows; each list item will be sent
to a corresponding input channel of the \code{Graph}. If \code{input} is a named \code{list}, names must correspond to input channel
names (\code{$input$name}) and inputs will be sent to the channels by name; otherwise they will be sent to the channels
in order in which they are listed in \code{$input}.
\item \code{predict(input, single_input = TRUE)} \cr
(\code{any}, \code{logical(1)}) -> \code{list} of \code{any} \cr
Predict with the \code{Graph} by calling all the \code{PipeOp}'s \code{$train} methods. Input and output, as well as the function
of the \code{single_input} argument, are analogous to \code{$train()}.
}
}

\examples{
g = Graph$new()$
  add_pipeop(PipeOpScale$new(id = "scale"))$
  add_pipeop(PipeOpPCA$new(id = "pca"))$
  add_edge("scale", "pca")
g$input
g$output

task = mlr3::mlr_tasks$get("iris")
trained = g$train(task)
trained[[1]]$data()

task$filter(1:10)
predicted = g$predict(task)
predicted[[1]]$data()
}
\seealso{
Other mlr3pipelines backend related: \code{\link{PipeOpTaskPreprocSimple}},
  \code{\link{PipeOpTaskPreproc}}, \code{\link{PipeOp}},
  \code{\link{mlr_pipeops}}
}
\concept{mlr3pipelines backend related}
\keyword{datasets}
